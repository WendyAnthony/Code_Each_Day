---
title: "RemoteSensing"
author: "Wendy Anthony"
date: "2022/04/15 - 2022/04/18"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

https://rspatial.org/raster/rs/2-exploration.html

# Data

## Download zipped data: https://biogeo.ucdavis.edu/data/rspatial/rsdata.zip 
## Unzip data
uncomment if not already zipped
```{r data-unzip}
# unzip('data/rsdata.zip', exdir='data')
```

# Image properties
"Create RasterLayer objects for single Landsat layers (bands)"
```{r image-properties}
library(raster)
# Blue
b2 <- raster('data/rs/LC08_044034_20170614_B2.tif')
# Green
b3 <- raster('data/rs/LC08_044034_20170614_B3.tif')
# Red
b4 <- raster('data/rs/LC08_044034_20170614_B4.tif')
# Near Infrared (NIR)
b5 <- raster('data/rs/LC08_044034_20170614_B5.tif')
```

## Check variables
see the spatial resolution, extent, number of layers, coordinate reference system, etc
```{r check-variables}
b2
b3
b4
b5
```

### Check CRS (coordinate reference system)

```{r}
# coordinate reference system (CRS)
crs(b2)
crs(b3)
crs(b4)
crs(b5)

# Number of cells, rows, columns
ncell(b2)

dim(b2)

# spatial resolution
res(b2)

# Number of bands
nlayers(b2)

# Do the bands have the same extent, number of rows and columns, projection, resolution, and origin
compareRaster(b2,b3)
```

# Create raster stack object of multiple layers from single raster band objects
```{r create-raster-stack}
s <- stack(b5, b4, b3)
s
plot(s)
plot(b5)
```

## Raster stacks created using filenames
### List filenames
```{r raster-filenames}
# create list of raster objects
filenames <- paste0("data/rs/LC08_044034_20170614_B", 1:11, ".tif")
filenames
```

### Create an 11 layer raster stack from all 11 filenames
"The layers represent reflection intensity in the following wavelengths: Ultra Blue, Blue, Green, Red, Near Infrared (NIR), Shortwave Infrared (SWIR) 1, Shortwave Infrared (SWIR) 2, Panchromatic, Cirrus, Thermal Infrared (TIRS) 1, Thermal Infrared (TIRS) 2.  
We won’t use the last four layers and you will see how to remove those in following sections."
```{r create-raster-stack-filenames}
landsat <- stack(filenames)
landsat
```

---

# Maps

## Grey-scale Single band and composite maps
plot individual layers in a 2x2 grid  
legend values between 0-1  
"different surface features reflect the incident solar radiation differently.  
Each layer represent how much incident solar radiation is reflected for a particular wavelength range.  
For example, vegetation reflects more energy in NIR than other wavelengths and thus appears brighter.  
In contrast, water absorbs most of the energy in the NIR wavelength and it appears dark."
```{r single-band-composite-maps}
par(mfrow = c(2, 2))
plot(b2, main = "Blue", col = gray(0:100 / 100))
plot(b3, main = "Green", col = gray(0:100 / 100))
plot(b4, main = "Red", col = gray(0:100 / 100))
plot(b5, main = "NIR", col = gray(0:100 / 100))
```

## True / natural colour image
"(vegetation in green, water blue etc), we need bands in the red, green and blue regions.  
For this Landsat image, band 4 (red), 3 (green), and 2 (blue) can be used."
```{r true-colour}
par(oma = c(2, 0, 1, 4)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
par(mai = c(0.8, 3.1, .55, 0.35))

landsatRGB <- stack(b4, b3, b2)
plotRGB(landsatRGB, axes = TRUE, stretch = "lin", main = "Landsat True Colour Composite")
```
## False colour image
```{r false-colour}
par(oma = c(2, 0, 1, 4)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
par(mai = c(0.8, 3.1, .55, 0.35))

landsatFCC <- stack(b5, b4, b3)
plotRGB(landsatFCC, axes = TRUE, stretch = "lin", main = "Landsat False Colour Composite")
```

## Compare True and False Colour Images
```{r compare-true-false-colour-image}
par(mfrow = c(1, 2))
par(oma = c(0, 0.5, 0, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "s") # "s" square plotting region vs m - maximal


plotRGB(landsatRGB, axes = TRUE, stretch = "lin", main = "Landsat True Colour Composite")

landsatFCC <- stack(b5, b4, b3)
plotRGB(landsatFCC, axes = TRUE, stretch = "lin", main = "Landsat False Colour Composite")
```

---

# Arguements to modify image
```{r}
help(plotRGB)
```

---

# Subset (indexing) and rename bands in landsat object of all layers
```{r subset-rename-bands}
# select first 3 bands
landsat

landsatsub1 <- subset(landsat, 4:2)
landsatsub1
# same as
landsatsub2 <- landsat[[4:2]]
landsatsub2

# Number of bands in the original and new data
nlayers(landsat)
nlayers(landsatsub1)
nlayers(landsatsub2)
```

## Remove last 4 bands that won't be used
```{r remove-last-four-bands}
landsat <- subset(landsat, 1:7)
landsat
```

## Rename Band names
```{r band-names}
names(landsat)

names(landsat) <- c('ultra-blue', 'blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')
names(landsat)
```

## Spatial subset or crop
"used to limit analysis to a geographic subset of the image"
```{r spatial-subset-crop}
extent(landsat)

e <- extent(624387, 635752, 4200047, 4210939)
e

# crop landsat by the extent
landsatcrop <- crop(landsat, e)
landsatcrop
```


# Compare landsat True and False Colour Images
```{r compare-false-colour-image-landsat}
par(mfrow = c(1, 2))

landsatsub3 <- subset(landsat, 4:2)
landsatsub4 <- subset(landsat, 5:3)

plotRGB(landsatsub3, axes = TRUE, stretch = "lin", main = "Landsat True Colour Composite")

plotRGB(landsatsub4, axes = TRUE, stretch = "lin", main = "Landsat False Colour Composite")
```

# Compare cropped landsat True and False Colour Images
## Cropped Landsat True Colour Image
```{r true-colour-image-landsat-crop}
par(ps = 9) # point text size
par(oma = c(0, 1.5, 1, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
par(mai = c(1.2, 4.2, .55, 0.35))
par(mar = c(5, 5, 4, 2))
# ?par # help for par() function

landsatsub5 <- subset(landsatcrop, 4:2)
plotRGB(landsatsub5, axes = TRUE, xlab = "UTM E/W", ylab = "UTM N/S", stretch = "lin", main = "Landsat\nTrue Colour Composite")
```


## Cropped Landsat False  Colour Image
```{r false-colour-image-landsat-crop}
par(ps = 9) # point text size
par(oma = c(0, 1.5, 1, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
par(mai = c(1.2, 4.2, .55, 0.35))
par(mar = c(5, 5, 4, 2))
# ?par # help for par() function

# title(sub = "Comparing True and False Colour Landsat Composites") # only works for area of one graph
# xlab = "UTM E/W", ylab = "UTM N/S",  takes too much space
landsatsub6 <- subset(landsatcrop, 5:3)
plotRGB(landsatsub6, axes = TRUE, stretch = "lin", main = "Landsat\nFalse Colour Composite")
```

## Compare cropped landsat True and False Colour Images
```{r compare-false-colour-image-landsat-crop}
par(mfrow = c(1, 2))
par(ps = 8) # point text size
par(oma = c(0, 0, 1, 0)) # margins: bottom, left, top (gives title space), right
# ?par # help for par() function

landsatsub5 <- subset(landsatcrop, 4:2)
plotRGB(landsatsub5, axes = TRUE, xlab = "UTM E/W", ylab = "UTM N/S", stretch = "lin", main = "Landsat\nTrue Colour Composite")

# title(sub = "Comparing True and False Colour Landsat Composites") # only works for area of one graph
landsatsub6 <- subset(landsatcrop, 5:3)
plotRGB(landsatsub6, axes = TRUE, xlab = "UTM E/W", ylab = "UTM N/S", stretch = "lin", main = "Landsat\nFalse Colour Composite")
```

---

# Saving results to disk
## Save as jpg
```{r save-plot-TCC-jpg}
jpeg(file="landsatRGB-TCC.jpeg")
plotRGB(landsatRGB, axes = TRUE, stretch = "lin", main = "Landsat True Colour Composite")
dev.off()

jpeg(file="landsatRGB-FCC.jpeg")
landsatFCC <- stack(b5, b4, b3)
plotRGB(landsatFCC, axes = TRUE, stretch = "lin", main = "Landsat False Colour Composite")
dev.off()
```

## Save plot as tiff
```{r save-plot-TCC-tiff}
tiff(file="landsatRGB-TCC.tif")
plotRGB(landsatRGB, axes = TRUE, stretch = "lin", main = "Landsat True Colour Composite")
dev.off()

tiff(file="landsatRGB-FCC.tif")
landsatFCC <- stack(b5, b4, b3)
plotRGB(landsatFCC, axes = TRUE, stretch = "lin", main = "Landsat False Colour Composite")
dev.off()
```
## Save writeRaster as tiff
```{r save-results-disk}
rf <- writeRaster(landsatcrop, filename = "cropped-landsat.tif", overwrite=TRUE)
rf <- writeRaster(landsatsub5, filename = "cropped-landsat5.tif", overwrite=TRUE)
rf <- writeRaster(s, filename = "cropped-landsat-TCC.tif", overwrite=TRUE)

# S4 method for RasterStackBrick,character

rf <- writeRaster(landsatFCC, filename=file.path("landsatFCC.tif"), format="GTiff", overwrite=TRUE)
rf <- writeRaster(landsatRGB, filename=file.path("landsatTCC.tif"), format="GTiff", overwrite=TRUE)

class(landsatcrop)
class(landsat)
```


---

# Relationships between raster layer Bands

## Plot of UV/B reflection correlation
There is a high correlation (99%) between the ultra-blue and blue wavelengths.  
so not much info will be lost if sing only one of these bands

```{r relation-between-bands-UV-V}
pairs(landsatcrop[[1:2]], main = "Correlation between Ultra-blue versus Blue")
```

## Plot of R/NIR wavelength reflection Correlation
A triangle distribution. Vegetation reflects higher in NIR than red wavelengths  
"and creates the upper corner close to NIR (y) axis.  
Water absorbs energy from all the bands and occupies the location close to origin.  
The furthest corner is created due to highly reflecting surface features like bright soil or concrete."
```{r relation-between-bands-R-NIR}
pairs(landsatcrop[[4:5]], main = "Red vs NIR")
```

---

# Land Cover

  ## Extract pixel values from land cover info polygons
```{r extract-pixel-values}
# load the polygons with land use land cover information
samp <- readRDS('data/rs/samples.rds')

# generate 300 point samples from the polygons
ptsamp <- spsample(samp, 300, type='regular')

# add the land cover class to the points
ptsamp$class <- over(ptsamp, samp)$class

# extract values with points
df <- extract(landsat, ptsamp)

# To see some of the reflectance values
head(df)
```

## Spectral profiles of land cover

```{r spectral-profiles}
ms <- aggregate(df, list(ptsamp$class), mean)

# instead of the first column, we use row names
rownames(ms) <- ms[,1]
ms <- ms[,-1]
ms
```

### Plot mean spectral Profile of features
"The spectral profile plots reflectance of different earth’s surface features  
‘Water’ has low reflection in all wavelengths  
‘built’, ‘fallow’ and ‘open’ have have high reflectance in longer wavelengths
```{r plot-spectra}
# Create a vector of color for the land cover classes for use in plotting
mycolor <- c('darkred', 'yellow', 'burlywood', 'cyan', 'blue')

#transform ms from a data.frame to a matrix
ms <- as.matrix(ms)

# First create an empty plot
plot(0, ylim=c(0,0.6), xlim = c(1,7), type='n', xlab="Bands", ylab = "Reflectance")

# add the different classes
for (i in 1:nrow(ms)){
  lines(ms[i,], type = "l", lwd = 3, lty = 1, col = mycolor[i])
}

# Title
title(main="Spectral Profile from Landsat", font.main = 2)

# Legend
legend("topleft", rownames(ms),
       cex=0.8, col=mycolor, lty = 1, lwd =3, bty = "n")
```

---

# Basic Math with ```raster```
performed on each pixel / grid cell

## Combine bands
### Data (same as above)
```{r combine-bands-data}
raslist <- paste0('data/rs/LC08_044034_20170614_B', 1:11, ".tif")
landsat <-stack(raslist)
landsatRGB <- landsat[[c(4, 3, 2)]]
landsatFCC <- landsat[[c(5, 4, 3)]]
```

### Function Vegetation Index
```{r vegetation-index-function}
vi <- function(img, k, i) {
  bk <- img[[k]]
  bi <- img[[i]]
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}
```


#### NDVI (Normalized Difference Vegetation Index)
to view greenness  
Landsat bands NIR = 5, red = 4
#### NDVI one way
```{r NDVI-1}
ndvi <- vi(landsat, 5, 4)
plot(ndvi, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Landsat NDVI", sub = "Level of greenness")
```

#### NDVI another function
```{r NDVI-2}
vi2 <- function(x, y){
  (x - y) / (x + y)
}
ndvi2 <- overlay(landsat[[5]], landsat[[4]], fun = vi2)
plot(ndvi, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Landsat NDVI", sub = "Level of greenness")
```

### Adapt code for other indices
see spectral profile for bands with max / min reflectance  

#### Function for 2 band index
```{r vegetation-indices-reused}
vi <- function(img, k, i) {
  bk <- img[[k]]
  bi <- img[[i]]
  vi <- (bk - bi) / (bk + bi)
  return(vi)
}
```

#### Water body index NDWI (Normalized difference water index)
Landsat bands: green = 3 and NIR = 5
```{r water-body-index}
ndwi <- vi(landsat, 3, 5)
plot(ndwi, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Water Body Index: Landsat Bands green (3) and NIR (5)", sub = "Monitor water in water bodies")
```

#### Water in leaf index NDWI (Normalized difference water index)
Landsat bands:  NIR = 5 and SWIR = 7  
(Note: very similar to Built Environment Index 2 Bands: NIR = 5 and green = 3)
```{r water-leaf-index-7}
ndwi2 <- vi(landsat, 5, 7)
plot(ndwi2, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Leaf Water Index: Landsat Bands NIR (5) and SWIR (7)", sub = "Monitor change in leaf water content")
```

#### Another try at Water in leaf index NDWI (Normalized difference water index)
Landsat bands:  NIR = 5 and SWIR = 6  
this is not the band to identify water in leaves
```{r water-leaf-index-6}
ndwi3 <- vi(landsat, 5, 6)
plot(ndwi3, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Leaf Water Index: Landsat Bands NIR (5) and SWIR (6)", sub = "Monitor change in leaf water content")
```

### Adapt code for other indices
see spectral profile for bands with max / min reflectance  
e.g. Identify built areas  NDBI (Normalized Difference Built-up Index)  
Landsat bands: 4 = red, 2 = green, 7 = SWIR  
https://pro.arcgis.com/en/pro-app/2.8/arcpy/spatial-analyst/ndbi.htm  

#### Function for Built Environment Index
```{r built-index-formula}
# bands 4 (red), 2 (blue), 7 (SWIR)
bi <- function(img, k, i, p) {
  bk <- img[[k]]
  bi <- img[[i]]
  bp <- img[[p]]
  bi <- (bk - bi) * bp / (bk + bi) * bp
  return(bi)
}
```
#### Built Environment Index 3 Bands
Landsat Bands: 4 = red, 2 = blue, 7 = SWIR  
https://pro.arcgis.com/en/pro-app/2.8/arcpy/spatial-analyst/ndbi.htm
```{r built-index-1}
ndbi <- bi(landsat, 4, 2, 7)
plot(ndbi, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Built Index: Landsat Bands red (4), blue (2), and SWIR (7)", sub = "Monitor change in built environment (4-2)*7/(4+2)*7")
```

#### Built Environment Index 2 Bands SWIR and NIR
Landsat bands: 6 = SWIR, 5 = NIR  
Note: this 2 band combo is not as good as the previous 3 band combo
https://pro.arcgis.com/en/pro-app/2.8/arcpy/spatial-analyst/ndbi.htm  
```{r built-index-2}
# bands 4 (red), 2 (blue), 7 (SWIR)
bi <- function(img, k, i) {
  bk <- img[[k]]
  bi <- img[[i]]
  
  bi <- (bk - bi) / (bk + bi) 
  return(bi)
}

ndbi2 <- bi(landsat, 6, 5)
plot(ndbi2, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Built Index: Landsat Bands SWIR (6) and NIR (5)", sub = "Monitor change in built environment (6-5)/(6+5)")
```

#### Built Environment Index 2 Bands red and NIR
Landsat bands: 4 = red, 5 = NIR  
** Don't Use (Note: too similar to Built Environment Index 2 Bands: NIR = 5 and green = 3)
https://pro.arcgis.com/en/pro-app/2.8/arcpy/spatial-analyst/ndbi.htm  

```{r built-index-2b}
bei <- vi(landsat, 4, 5)
plot(bei, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Built Index: Landsat Bands NIR (5) and green (3)", sub = "Monitor change in built environment")
```

# Comparison Plots
## Compare Land Use Change Plots
```{r land-use-change-plot-comparison}
par(mfrow = c(2, 2)) # rows, columns
par(ps = 8) # point text size
par(oma = c(0, 0, 1, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
par(mai = c(0.35, 0.35, 0.35, 0.35))
# ?par # help for par() function

###############
# NDVI plot
ndvi <- vi(landsat, 5, 4)
plot(ndvi, col = rev(terrain.colors(10)), main = "Landsat NDVI Greeness Index")

###############
# NDWI plot leaf water
ndwi2 <- vi(landsat, 5, 7)
plot(ndwi2, col = rev(terrain.colors(10)), main = "Leaf Water Index: Landsat Bands NIR (5) and SWIR (7)")

###############
# NDWI plot water bodies
ndwi <- vi(landsat, 3, 5)
plot(ndwi, col = rev(terrain.colors(10)), main = "Water Body Index: Landsat Bands green (3) and NIR (5)")

###############
# Built environment index
# bands 4 (red), 2 (blue), 7 (SWIR)
bi <- function(img, k, i, p) {
  bk <- img[[k]]
  bi <- img[[i]]
  bp <- img[[p]]
  bi <- (bk - bi) * bp / (bk + bi) * bp
  return(bi)
}

ndbi <- bi(landsat, 4, 2, 7)
plot(ndbi, col = rev(terrain.colors(10)), main = "Built Index: Landsat Bands Red, Green and SWIR [(4-2)*7/(4+2)*7]")
```

## Compare cropped image Land Use Change Plots
```{r land-use-change-plot-comparison-crop}
par(mfrow = c(2, 2)) # rows, columns
par(ps = 8) # point text size
par(oma = c(0, 0, 1, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
par(mai = c(0.35, 0.35, 0.35, 0.35))
# ?par # help for par() function

###############
# NDVI plot
ndvi_crop <- vi(landsatcrop, 5, 4)
plot(ndvi_crop, col = rev(terrain.colors(10)), main = "Landsat NDVI Greeness Index")

###############
# NDWI plot leaf water
ndwi2_crop <- vi(landsatcrop, 5, 7)
plot(ndwi2_crop, col = rev(terrain.colors(10)), main = "Leaf Water Index: Landsat Bands NIR (5) and SWIR (7)")

###############
# NDWI plot water bodies
ndwi_crop <- vi(landsatcrop, 3, 5)
plot(ndwi_crop, col = rev(terrain.colors(10)), main = "Water Body Index: Landsat Bands green (3) and NIR (5)")
###############
# Built environment index
# bands 4 (red), 2 (blue), 7 (SWIR)
bi <- function(img, k, i, p) {
  bk <- img[[k]]
  bi <- img[[i]]
  bp <- img[[p]]
  bi <- (bk - bi) * bp / (bk + bi) * bp
  return(bi)
}

ndbi_crop <- bi(landsatcrop, 4, 2, 7)
plot(ndbi_crop, col = rev(terrain.colors(10)), main = "Built Index: Landsat Bands Red, Green and SWIR [(4-2)*7/(4+2)*7]")
```

## Spectral Plot
```{r plot-spectra-2}

###############
# Plot Spectra
# Create a vector of color for the land cover classes for use in plotting
mycolor <- c('darkred', 'yellow', 'burlywood', 'cyan', 'blue')

#transform ms from a data.frame to a matrix
ms <- as.matrix(ms)

# First create an empty plot
plot(0, ylim=c(0,0.6), xlim = c(1,7), type='n', xlab="Bands", ylab = "Reflectance")

# add the different classes
for (i in 1:nrow(ms)){
  lines(ms[i,], type = "l", lwd = 3, lty = 1, col = mycolor[i])
}

# Title
title(main="Spectral Profile from Landsat", font.main = 2)

# Legend
legend("topleft", rownames(ms),
       cex=0.8, col=mycolor, lty = 1, lwd =3, bty = "n")
```

---

# Histograms
## NDVI values distribution
```{r histogram-ndvi}
hist(ndvi, 
     main = "NDVI value distribution",
     xlab = "NDVI",
     ylab = "Frequency",
     col = "darkolivegreen",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

## NDVI values distribution cropped
```{r histogram-ndvi-crop}
hist(ndvi_crop, 
     main = "NDVI value distribution - crop",
     xlab = "NDVI",
     ylab = "Frequency",
     col = "darkolivegreen",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```
## NDWI values distribution
```{r histogram-ndwi}
hist(ndwi, 
     main = "NDWI water body value distribution",
     xlab = "NDWI",
     ylab = "Frequency",
     col = "cyan",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

## NDWI values distribution cropped
```{r histogram-ndwi-crop}
hist(ndwi_crop, 
     main = "NDWI water body value distribution cropped",
     xlab = "NDWI",
     ylab = "Frequency",
     col = "cyan",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

## NDWI2 Leaf water values distribution
```{r histogram-ndwi2}
hist(ndwi2, 
     main = "NDWI leaf water value distribution",
     xlab = "NDWI",
     ylab = "Frequency",
     col = "aquamarine",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```
## NDWI2 Leaf water values distribution crop
```{r histogram-ndwi2-crop}
hist(ndwi2_crop, 
     main = "NDWI leaf water value distribution cropped",
     xlab = "NDWI",
     ylab = "Frequency",
     col = "aquamarine",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

## Built Environment index values distribution
```{r histogram-ndbi}
hist(ndbi, 
     main = "NDWI value distribution",
     xlab = "NDWI",
     ylab = "Frequency",
     col = "azure",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

## Built Environment index values distribution cropped
```{r histogram-ndbi-crop}
hist(ndbi_crop, 
     main = "NDWI value distribution cropped",
     xlab = "NDWI",
     ylab = "Frequency",
     col = "azure",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

---

# Thresholding
to estimate spatial extent of surface features

## NDVI Threshold
values -1 to +1, with higher values more vegetation cover   
NDVI > 0.4 is definitely vegetation  
to mask all cells not vegetation
```{r ndvi-threshold}
veg <- reclassify(ndvi, cbind(-Inf, 0.4, NA))
plot(veg, main = "Vegetation")
```

### compare to before reclassification
```{r NDVI-1-replot}
ndvi <- vi(landsat, 5, 4)
plot(ndvi, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Landsat NDVI", sub = "Level of greenness")
```



## map the histogram peack between 0.25 and 0.3
```{r ndvi-peak-threshold}
land <- reclassify(ndvi, c(-Inf, 0.25, NA, 0.25, 0.3, 1, 0.3, Inf, NA))
plot(land, main = "What is it?")
```


### NDVI values distribution histogram
```{r histogram-ndvi-replot}
hist(ndvi, 
     main = "NDVI value distribution",
     xlab = "NDVI",
     ylab = "Frequency",
     col = "darkolivegreen",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

## Compare NDVI Threshold plots
```{r comparison-NDVI-threshold}
par(mfrow = c(2, 2)) # rows, columns
par(ps = 8) # point text size
par(oma = c(0, 0, 1, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
par(mai = c(0.35, 0.35, 0.35, 0.35))
# ?par # help for par() function

###############

veg <- reclassify(ndvi, cbind(-Inf, 0.4, NA))
plot(veg, main = "Vegetation")

###############

land <- reclassify(ndvi, c(-Inf, 0.25, NA, 0.25, 0.3, 1, 0.3, Inf, NA))
plot(land, main = "What is it? Open Land?")

###############

ndvi <- vi(landsat, 5, 4)
plot(ndvi, col = rev(terrain.colors(10)), xlab = "UTM W/E", ylab = "UTM N/S", main = "Landsat NDVI", sub = "Level of greenness")

###############
hist(ndvi, 
     main = "NDVI value distribution",
     xlab = "NDVI",
     ylab = "Frequency",
     col = "darkolivegreen",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

#### Test To See if open land?
```{r land-landsatTCC}
plotRGB(landsatRGB, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat True Color Composite")
plot(land, add=TRUE, legend=FALSE)
```
#### Compare NDVI Land Threshold with True Colour Composite Image
```{r comparison-NDVI-threshold-TCC}
par(mfrow = c(2, 2)) # rows, columns
par(ps = 10) # point text size
par(oma = c(0, 0, 0, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
# ?par # help for par() function

###############
plotRGB(landsatRGB, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat True Color Composite")
###############
plotRGB(landsatRGB, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat True Color Land Composite")
plot(land, add=TRUE, legend=FALSE)
###############
plotRGB(landsatFCC, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat False Color Composite")
###############
plotRGB(landsatFCC, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat False Color Land Composite")
plot(land, add=TRUE, legend=FALSE)
```

#### Compare NDVI Vegetation Threshold with False Colour Composite Image
```{r comparison-NDVI-threshold-FCC}
par(mfrow = c(2, 2)) # rows, columns
par(ps = 10) # point text size
par(oma = c(0, 0, 0, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
# ?par # help for par() function

###############
plotRGB(landsatRGB, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat True Color Composite")
###############
plotRGB(landsatRGB, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat True Color Vegetation Composite")
plot(veg, add=TRUE, legend=FALSE)
###############
plotRGB(landsatFCC, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat False Color Composite")
###############
plotRGB(landsatFCC, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat False Color Vegetation Composite")
plot(veg, add=TRUE, legend=FALSE)
```

## Create Vegetation Classes
```{r vege-classes}
vegc <- reclassify(ndvi, c(-Inf,0.25,1,  0.25,0.3,2,  0.3,0.4,3,  0.4,0.5,4,  0.5,Inf,5))
plot(vegc, main = "Vegetation Classification\nNDVI based thresholding", sub = "Thresholds: -Inf,0.25,1,  0.25,0.3,2,  0.3,0.4,3,  0.4,0.5,4,  0.5,Inf,5")
```
### Compare NDVI Vegetation Threshold with Histogram of Values
```{r comparison-NDVI-vege-threshold-hist}
par(mfrow = c(1,2))

vegc <- reclassify(ndvi, c(-Inf,0.25,1,  0.25,0.3,2,  0.3,0.4,3,  0.4,0.5,4,  0.5,Inf,5))
plot(vegc, main = "Vegetation Classification", sub = "Thresholds: -Inf,0.25,1,  0.25,0.3,2,  0.3,0.4,3,  0.4,0.5,4,  0.5,Inf,5")
###############
hist(ndvi, 
     main = "NDVI value distribution",
     xlab = "NDVI",
     ylab = "Frequency",
     col = "darkolivegreen",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-0.5, 1, 0.05), labels = seq(-0.5, 1, 0.05))
```

## Can I use this idea to predict where to find water?

### Create Water Classes
https://bootstrappers.umassmed.edu/bootstrappers-courses/pastCourses/rCourse_2016-04/Additional_Resources/Rcolorstyle.html
```{r water-classes-1}
waterc <- reclassify(ndvi, c(-Inf,0.1,1,  0.1,0.15,2,  0.15,0.25,3,  0.25,0.35,4,  0.35,0.4,5,  0.4,Inf,6))
plot(waterc, col = cm.colors(10), main = "Water Classification\nNDWI based thresholding", sub = "Thresholds: --Inf,0.1,1,  0.1,0.15,2,  0.15,0.25,3,  0.25,0.35,4,  0.35,0.4,5,  0.4,Inf,6")
```


### Reclassify water again
```{r water-classes-3}
waterc2 <- reclassify(ndvi, c(-Inf,-0.55,1,  -0.55,-0.45,2,  -0.45,-0.35,3,  -0.35,-0.25,4,  -0.25,-0.15,5, -0.15,0.,6,  0,0.15,7,  0.15,1.5,8, 1.5,2.5,9, 2.5,3.5,10,  3.5,Inf,11))
plot(waterc2, col = cm.colors(10), main = "Water Classification\nNDWI based thresholding", sub = "Thresholds: -Inf,-0.55,1,  -0.55,-0.45,2,  -0.45,-0.35,3,  -0.35,-0.25,4,  -0.25,-0.15,5, \n-0.15,0.,6,  0,0.15,7,  0.15,1.5,8, 1.5,2.5,9, 2.5,3.5,10,  3.5,Inf,11")
```

### Reclassify water yet again to peak
waterc2 <- reclassify(ndvi, c(-Inf,0.1,1,  0.1,0.35,2,  0.35,Inf,NA))
col = rev(hsv(0.5, seq(0,.50,length.out = 12), .85))
```{r water-classes-2}
waterc2 <- reclassify(ndvi, c(-Inf,-0.05,1,  -0.05,Inf,NA))
plot(waterc2, col = rev("cyan"), main = "Water Classification\nNDWI based thresholding", sub = "Frequency Thresholds: -Inf,-0.05,1,  -0.05,Inf,NA", legend = FALSE)
```


### NDWI values distribution
find frequency >0 e.g. 0 to 0.65
```{r histogram-ndwi-replot}
hist(ndwi, 
     main = "NDWI water body value distribution",
     xlab = "NDWI",
     ylab = "Frequency",
     col = "cyan",
     xlim = c(-0.5, 1),
     breaks = 30,
     xaxt = "n"
     )
axis(side = 1, at = seq(-1, 1, 0.05), labels = seq(-1, 1, 0.05))
```
##### Compare NDVI Water Threshold with True Colour Composite Image
```{r comparison-NDVI-water-threshold-TCC}
par(mfrow = c(2, 2)) # rows, columns
par(ps = 8) # point text size
par(oma = c(0, 0, 0, 0)) # margins: bottom, left, top (gives title space), right
par(pty = "m") # "s" square plotting region vs m - maximal
# ?par # help for par() function

###############
plotRGB(landsatRGB, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat True Color Composite")
###############
plotRGB(landsatRGB, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat True Color Water NDWI Composite")
plot(waterc2, col = rev("cyan"), add=TRUE, legend=FALSE)
###############
plotRGB(landsatFCC, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat False Color Composite")
###############
plotRGB(landsatFCC, r=1, g=2, b=3, axes=TRUE, stretch="lin", main="Landsat False Color Water NDWI Composite")
plot(waterc2, col = rev("cyan"), add=TRUE, legend=FALSE)
```

---

# Principal component analysis (PCA)
reduces data noise by reduction >>  
the first PC explains most % variance, others in decreasing order

## Create vegetation - soil line plot (same as earlier scatter plot NIR-red bands)
```{r pca-plot}
set.seed(1)
sr <- sampleRandom(landsat, 10000)
plot(sr[,c(4,5)], main = "NIR-Red plot")
```
## Calculate PCA
```{r pca-calc}
pca <- prcomp(sr, scale = TRUE)
pca
```
### Histogram of pca variances
```{r pca-plot-histogram}
screeplot(pca)
```
### Plot of prediction
"The first principal component highlights the boundaries between land use classes or spatial details, which is the most common information among all wavelengths."
```{r pca-predict-pci}
pci <- predict(landsat, pca, index = 1:2)
plot(pci[[1]])
```
## Thresholding the PCA
"It is difficult to understand what the second principal component is highlighting. Lets try thresholding again:"
```{r pca-reclassify}
pc2 <- reclassify(pci[[2]], c(-Inf,0,1, 0,Inf,NA))
par(mfrow = c(1,2))
plotRGB(landsatFCC, r = 1, g = 2, b = 3, axes = TRUE, stretch = "lin", main = "Landsat False Color Composite")
plotRGB(landsatFCC, r = 1, g = 2, b = 3, axes = TRUE, stretch = "lin", main = "Landsat False Color Composite")
plot(pc2, legend = FALSE, add = TRUE)
```


---

# Unsupervised Classification

## Data
```{r unsupervised-class}
landsat5 <- stack('data/rs/centralvalley-2011LT5.tif')
names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')
```

## Make a 3-band False Color Composite plot of ``landsat5``
```{r plot-landsat5}
plot(landsat5)
landsat5
```
## Plot FCC with 3 bands NIR, red, green
```{r plot-landsat5-FCC}
#landsat5_FCC <- stack(b5, b4, b3)
landsat5_FCC <- stack(b5, b4, b3)
plotRGB(landsat5_FCC, axes = TRUE, stretch = "lin", main = "Landsat False Colour Composite")
```

## Unsupervised classification K-means
"In unsupervised classification, we use the reflectance data, but we don’t supply any response data  
(that is, we do not identify any pixel as belonging to a particular class).  
The algorithm groups pixels with similar spectral characteristics into groups."  
### NDVI subset
```{r ndvi-spatial-subset}
ndvi_sub <- (landsat5[["NIR"]] - landsat5[["red"]] / (landsat5[["NIR"]] + landsat5[["red"]]))
```

### K-means clustering of ndvi_sub data >> crop
```{r k-means-crop}
# Extent to crop ndvi layer
e <- extent(-121.807, -121.725, 38.004, 38.072)
# crop landsat by the extent
ndvi_sub <- crop(ndvi_sub, e)
ndvi_sub
```

### Convert raster layer to vector (array/matrix)
```{r convert-raster-to-vector}
# convert the raster to vector/matrix
nr <- getValues(ndvi_sub)
str(nr)
```
### K-means
"kmeans returns an object with 9 elements. The length of the cluster element within kmncluster is 76608 which same as length of nr created from the ndvi. The cell values of ```kmncluster$cluster``` range between 1 to 10 corresponding to the input number of cluster we provided in the kmeans function. ```kmncluster$cluster``` indicates the cluster label for corresponding pixel. We need to convert the kmncluster$cluster values back to RasterLayer of the same dimension as the ndvi."
```{r kmeans-clustering-matrix}
# It is important to set the seed generator because `kmeans` initiates the centers in random locations
set.seed(99)

# We want to create 10 clusters, allow 500 iterations, start with 5 random sets using "Lloyd" method
kmncluster <- kmeans(na.omit(nr), centers = 10, iter.max = 500, nstart = 5, algorithm="Lloyd")
# kmeans returns an object of class "kmeans"
str(kmncluster)
```

### Set cluster values
```{r set-cluster-values}
# Use the ndvi object to set the cluster values to a new raster
knr <- setValues(ndvi_sub, kmncluster$cluster)
# You can also do it like this
knr <- raster(ndvi_sub)
values(knr) <- kmncluster$cluster
knr
```
### Define colour vector for clusters
"We can see that knr is a RasterLayer but we do not know which cluster (1-10) belongs to what land cover class  
(and if it does belong to a class that we would recognize).  
You can find that out by plotting them side-by-side with a reference layers and using unique color for each cluster."  
  
"While for other purposes it is usually better to define more classes (and possibly merge classes later), a simple classification like this one could be useful, e.g., merge cluster 4 and 5 to construct a water mask for the year 2011."
```{r define-color-vector}
# Define a color vector for 10 clusters (learn more about setting the color later)
mycolor <- c("#fef65b","#ff0000", "#daa520","#0000ff","#0000ff","#00ff00","#cbbeb5",
             "#c3ff5b", "#ff7373", "#00ff00", "#808080")
par(mfrow = c(1,2))
plot(ndvi_sub, col = rev(terrain.colors(10)), main = 'Landsat-NDVI')
plot(knr, main = 'Unsupervised classification', col = mycolor )
```

#### Question:
Plot 3-band RGB of ``landsat5`` for the subset (extent ``e``) and result of ``kmeans`` clustering side-by-side and make a table of land-use land-cover labels for the clusters. E.g. cluster 4 and 5 are water.

---

# Supervised Classification
## Data nlcd
```{r nlcd-data}
nlcd <- brick('data/rs/nlcd-L1.tif')
names(nlcd) <- c("nlcd2001", "nlcd2011")
```

### Create class names and plot colours
```{r plot-colours-class}
# The class names and colors for plotting
nlcdclass <- c("Water", "Developed", "Barren", "Forest", "Shrubland", "Herbaceous", "Planted/Cultivated", "Wetlands")
classdf <- data.frame(classvalue1 = c(1,2,3,4,5,7,8,9), classnames1 = nlcdclass)
# Hex codes of colors
classcolor <- c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C", "#D1D182", "#FBF65D", "#C8E6F8")
```

### Ratify (RAT = "Raster Attribute Table")
```{r}
# Now we ratify (RAT = "Raster Attribute Table") the ncld2011 (define RasterLayer as a categorical variable). This is helpful for plotting.
nlcd2011 <- nlcd[[2]]
nlcd2011 <- ratify(nlcd2011)
rat <- levels(nlcd2011)[[1]]
#
rat$landcover <- nlcdclass
levels(nlcd2011) <- rat
```

## Generate sample sites
```{r generate-sample-sites}
# Load the training sites locations
# Set the random number generator to reproduce the results
set.seed(99)
# Sampling stratified
samp2011 <- sampleStratified(nlcd2011, size = 200, na.rm = TRUE, sp = TRUE)
samp2011

# Number of samples in each class
# 2 variables:  cell - # Cells of nlcd2011; nlcd2011 contains class values (1-9)
table(samp2011$nlcd2011)
```

### Plot training sites over nlcd2011 RasterLayer 
visualizes sampling locations distribution
```{r plot-training-sites-raster}
library(rasterVis)
plt <- levelplot(nlcd2011, col.regions = classcolor, main = 'Distribution of Training Sites')
print(plt + layer(sp.points(samp2011, pch = 3, cex = 0.5, col = 1)))
```
## Extract values for sites
### load data
```{r data-reload}
landsat5 <- stack('data/rs/centralvalley-2011LT5.tif')
names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')
```

### Extract cell values
```{r extract-site-values}
# Extract the layer values for the locations
sampvals <- extract(landsat5, samp2011, df = TRUE)
# sampvals no longer has the spatial information. To keep the spatial information you use `sp=TRUE` argument in the `extract` function.
# drop the ID column
sampvals <- sampvals[, -1]
# combine the class information with extracted values
sampdata <- data.frame(classvalue = samp2011@data$nlcd2011, sampvals)
```

### Train the classifier
"classvalues are printed at the leaf nodes.  
Find corresponding land use land cover names from the classdf data.frame."  
  
See ?rpart.control to set different parameters for building the model.  
You can print/plot more about the cart model created in the previous example.  
E.g. you can use plotcp(cart) to learn about the cost-complexity (cp argument in rpart)
```{r train-classifier}
library(rpart)
# Train the model
cart <- rpart(as.factor(classvalue)~., data=sampdata, method = 'class', minsplit = 5)
# print(model.class)
# Plot the trained classification tree
plot(cart, uniform=TRUE, main="Classification Tree")
text(cart, cex = 0.8)
```

## Classify
use training model to make predictions from all cells in raster stack
```{r predict-subset}
# Now predict the subset data based on the model; prediction for entire area takes longer time
pr2011 <- predict(landsat5, cart, type='class')
pr2011
```
## Plot results of classification
```{r plot-classification}
pr2011 <- ratify(pr2011)
rat <- levels(pr2011)[[1]]
rat$legend <- classdf$classnames
levels(pr2011) <- rat
levelplot(pr2011, maxpixels = 1e6,
          col.regions = classcolor,
          scales=list(draw=FALSE),
          main = "Decision Tree classification of Landsat 5")
```

### Question:
Plot ``nlcd2011`` and ``pr2011`` side-by-side and comment about the accuracy of the prediction (e.g. mixing between cultivated crops, pasture, grassland and shrubs).  
You may need to select more samples and use additional predictor variables.  
The choice of classifier also plays an important role.

## Model evaluation with k-fold cross-validation
"data used to fit the model is split into k groups (typically 5 groups).  
In turn, one of the groups will be used for model testing, while the rest of the data is used for model training (fitting)."

### Split into k groups
```{r model-evaluation}
library(dismo)
set.seed(99)
j <- kfold(sampdata, k = 5, by=sampdata$classvalue)
table(j)
```

### Train and test model
"five times, each time computing a confusion matrix that we store in a list."
```{r model-test-train}
x <- list()
for (k in 1:5) {
    train <- sampdata[j!= k, ]
    test <- sampdata[j == k, ]
    cart <- rpart(as.factor(classvalue)~., data=train, method = 'class', minsplit = 5)
    pclass <- predict(cart, test, type='class')
    # create a data.frame using the reference and prediction
    x[[k]] <- cbind(test$classvalue, as.integer(pclass))
}
```

### Create confusion matrix
Now combine the five list elements into a single data.frame, using do.call and compute a confusion matrix.
```{r combine-list-confusion-matrix}
y <- do.call(rbind, x)
y <- data.frame(y)
colnames(y) <- c('observed', 'predicted')
conmat <- table(y)
# change the name of the classes
colnames(conmat) <- classdf$classnames
rownames(conmat) <- classdf$classnames
conmat
```

#### Questions
Question 2:Comment on the miss-classification between different classes.  
Question 3:Can you think of ways to to improve the accuracy.


### Compute overall accuracy
```{r compute-accuracy}
# number of cases
n <- sum(conmat)
n

# number of correctly classified cases per class
diag <- diag(conmat)
# Overall Accuracy
OA <- sum(diag) / n
OA
```
### Compute the “Kappa” statistic
```{r compute-kappa-stat}
# observed (true) cases per class
rowsums <- apply(conmat, 1, sum)
p <- rowsums / n

# predicted cases per class
colsums <- apply(conmat, 2, sum)

q <- colsums / n
expAccuracy <- sum(p*q)
kappa <- (OA - expAccuracy) / (1 - expAccuracy)
kappa
```

### Producer and user accuracy
```{r producer-user-accuracy}
# Producer accuracy
PA <- diag / colsums
# User accuracy
UA <- diag / rowsums
outAcc <- data.frame(producerAccuracy = PA, userAccuracy = UA)
outAcc
```

#### Questions
Question 4:Perform the classification using Random Forest classifiers from the ``randomForest`` package
  
Question 5:Plot the results of rpart and Random Forest classifier side-by-side.
  
Question 6 (optional):Repeat the steps for the year 2001 using Random Forest. Use the cloud-free composite image data/centralvalley-2001LE7.tif. This is Landsat 7 data . Use as reference data the National Land Cover Database 2001 (NLCD 2001) for the subset of the California Central Valley.*
  
Question 7 (optional):We have trained the classifiers using 200 samples for each class. Investigate the effect of sample size on classification. Repeat the steps with different subsets, e.g. a sample size of 150, 100, 50 per class, and compare the results. Use the same holdout samples for model evaluation.
  








